import 'package:flutter/material.dart';
import '../Objects/template.dart';

import 'dart:io';
import 'package:pdf/widgets.dart' as pw;
import 'package:pdf/pdf.dart';
import 'package:flutter_pdfview/flutter_pdfview.dart';
import 'package:path_provider/path_provider.dart';
import 'package:flutter_email_sender/flutter_email_sender.dart';

/*
  On this page the user can see a summary of their session, including notes taken, time spent, etc.
  There should be an option to export the notes as a text file or PDF
  For Jackie the option to export should go straight to her email
 */

class SessionSummary extends StatefulWidget {
  final Template template;

  const SessionSummary({super.key, required this.template});

  @override
  State<SessionSummary> createState() => _SessionSummaryState();
}

class _SessionSummaryState extends State<SessionSummary> {
  final pw.Document pdf = pw.Document();
  String pdfPath = ''; // this will be updated based on the OS the device uses
  bool pdfExported = false;

  final ScrollController _scrollController = ScrollController();

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  // Create and return a new PDF document containing the session summary.
  pw.Document generatePdf() {
    final doc = pw.Document();

    // could introduce custom fonts / text formatting?

    int questions = widget.template.notes.length;
    int totalPages = (questions / 10).ceil();

    for (int i = 0; i < questions; i += 10) {
      final endIndex = (i + 10 < questions) ? i + 10 : questions;
      final pageNotes = widget.template.notes.sublist(i, endIndex);
      final currentPage = (i / 10).floor() + 1;

      doc.addPage(
        pw.Page(
          build: (pw.Context context) {
            return pw.Stack(
              children: [
                // Main content
                pw.Column(
                  crossAxisAlignment: pw.CrossAxisAlignment.start,
                  children: [
                    pw.Text(
                      widget.template.name,
                      style: pw.TextStyle(
                        fontSize: 24,
                        fontWeight: pw.FontWeight.bold,
                      ),
                    ),
                    pw.SizedBox(height: 12),
                    ...pageNotes.map(
                      (note) => pw.Column(
                        crossAxisAlignment: pw.CrossAxisAlignment.start,
                        children: [
                          pw.Text(
                            note.question,
                            style: pw.TextStyle(
                              fontSize: 18,
                              fontWeight: pw.FontWeight.bold,
                            ),
                          ),
                          pw.Text(
                            note.getValueString() ?? '',
                            style: pw.TextStyle(fontSize: 16),
                          ),
                          pw.SizedBox(height: 8),
                        ],
                      ),
                    ),
                  ],
                ),
                pw.Positioned(
                  bottom: 20,
                  left: 0,
                  right: 0,
                  child: pw.Container(
                    alignment: pw.Alignment.center,
                    child: pw.Text(
                      'Generated by Hands Free Notes - ${DateTime.now().toString().split(' ')[0]} | Page $currentPage of $totalPages',
                      style: pw.TextStyle(
                        fontSize: 10,
                        color: PdfColors.grey600,
                      ),
                    ),
                  ),
                ),
              ],
            );
          },
        ),
      );
    }
    return doc;
  }

  Future<bool> exportPdf() async {
    try {
      // Generate a fresh document for each export to avoid duplicate pages
      final doc = generatePdf();

      if (Platform.isAndroid) {
        // Try to get the shared Downloads directory on Android
        final dirs = await getExternalStorageDirectories(
          type: StorageDirectory.downloads,
        );
        if (dirs != null && dirs.isNotEmpty) {
          pdfPath = '${dirs.first.path}/${widget.template.name}.pdf';
        } else {
          final directory = await getApplicationDocumentsDirectory();
          pdfPath = '${directory.path}/${widget.template.name}.pdf';
        }
      } else {
        final directory = await getApplicationDocumentsDirectory();
        pdfPath = '${directory.path}/${widget.template.name}.pdf';
      }

      final file = File(pdfPath);
      final bytes = await doc.save();
      await file.writeAsBytes(bytes);

      // Print the saved file path to the console for debugging
      print('PDF exported to: $pdfPath');

      pdfExported = true;
      return true;
    } catch (e) {
      print('PDF export failed: $e');
      return false;
    }
  }

  Future<bool> emailPdf() async {
    try {
      // attempt to email pdf
      if (!pdfExported) {
        print('PDF must be exported first!');
        return false;
      }

      final Email email = Email(
        subject: '${widget.template.name}.pdf',
        recipients: [
          'pasimia@wwu.edu',
        ], // TO DO this should be a user email that is saved
        attachmentPaths: [pdfPath],
      );

      await FlutterEmailSender.send(email);

      return true;
    } catch (e) {
      print('PDF email failed: $e');
      return false;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => Navigator.of(context).pop(),
        ),
        title: Text(widget.template.name),
        centerTitle: true,
      ),
      body: SafeArea(
        child: Column(
          children: [
            Expanded(
              child: Container(
                color: Colors.white,
                padding: const EdgeInsets.all(16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      widget.template.name,
                      style: TextStyle(
                        fontSize: 24,
                        fontWeight: FontWeight.bold,
                      ),
                    ), // change title to be session.title
                    SizedBox(height: 12),
                    Expanded(
                      child: Center(
                        child: Scrollbar(
                          controller: _scrollController,
                          thumbVisibility: true,
                          thickness: 6.0,
                          radius: Radius.circular(3),
                          child: ListView.builder(
                            controller: _scrollController,
                            itemCount: widget.template.notes.length,
                            itemBuilder: (context, index) {
                              final note = widget.template.notes[index];
                              return ListTile(
                                title: Text(note.question),
                                subtitle: Text((note.getValueString() ?? '')),
                              );
                            },
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: Row(
                // Changed back to Column for vertical layout to ensure buttons are visible
                children: [
                  ElevatedButton(
                    onPressed: () async {
                      try {
                        // Export PDF (exportPdf generates a fresh document internally)
                        if (await exportPdf()) {
                          ScaffoldMessenger.of(context).showSnackBar(
                            SnackBar(
                              content: Text(
                                'PDF exported as ${widget.template.name}.pdf',
                              ),
                            ),
                          );
                        } else {
                          ScaffoldMessenger.of(context).showSnackBar(
                            SnackBar(
                              content: Text(
                                'Failed to export pdf: (insert error handling here)',
                              ),
                            ),
                          );
                        }
                      } catch (e) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(content: Text('Failed to export pdf: $e')),
                        );
                      }
                    },
                    child: Text('Export Notes'),
                  ),
                  SizedBox(width: 16), // Spacing between buttons6
                  ElevatedButton(
                    onPressed: () async {
                      try {
                        await emailPdf();
                      } catch (e) {
                        // print an error msg
                      }
                    },
                    child: Text('Email Notes'),
                  ),
                  SizedBox(width: 16),
                  ElevatedButton(
                    onPressed: () async {
                      try {
                        // if pdf doesn't exist yet -> error and display message to export pdf
                        if (!pdfExported)
                          throw Exception("PDF hasn't been saved yet!");
                        //display a popup with pdf view
                        showDialog(
                          context: context,
                          builder: (BuildContext context) {
                            return AlertDialog(
                              title: const Text("PDF"),
                              content: SizedBox(
                                width: double.maxFinite,
                                height:
                                    MediaQuery.of(context).size.height * 0.7,
                                child: PopupPDFViewer(path: pdfPath),
                              ),
                              actions: [
                                TextButton(
                                  child: const Text("Close"),
                                  onPressed: () {
                                    Navigator.of(
                                      context,
                                    ).pop(); // Closes the dialog
                                  },
                                ),
                              ],
                            );
                          },
                        );
                      } catch (e) {
                        //print an error msg
                      }
                    },
                    child: Text('View PDF'),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class PopupPDFViewer extends StatelessWidget {
  final String path;
  const PopupPDFViewer({Key? key, required this.path});

  @override
  Widget build(BuildContext context) {
    return PDFView(
      filePath: path,
      enableSwipe: true,
      swipeHorizontal: false,
      autoSpacing: false,
      pageFling: false,
      backgroundColor: Colors.blue,
      onError: (error) {
        print(error.toString());
      },
      onPageError: (page, error) {
        print('$page: ${error.toString()}');
      },
    );
  }
}
